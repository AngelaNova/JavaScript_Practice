<!DOCTYPE html>
<html>
  <head>
    <title>Advance Functions</title>
   
  </head>
  <body>
    <button class="js-button" onclick="
      
      ">Click</button>
    <script>


      //advantage - multiple event listeners
       const buttonElement = document.querySelector('.js-button');
       const eventListener = () =>{
        console.log('click');
       }
       
       buttonElement.addEventListener('click',eventListener);
      
      //we can even remove eventListener
      buttonElement.removeEventListener('click', eventListener);

      buttonElement.addEventListener('click', () => {
        console.log('click2');
      });


      function greeting(){
        console.log('hello');
      }

      greeting();  //calling/running the function

      //functions are values, thus we can save the function in a variable

      const num=2;
      const function1= function greeting(){
        console.log('hello2');
      }

      console.log(function1);
      console.log(typeof function1);
      function1();

    // this is an annoyimous function - w/o the name 
     // const function1= function(){
     //   console.log('hello2');
     // } con: you cannot call the function prior to it's establisment

     const object1={
      num:2,
      fun: function greeting(){
        console.log('hello3');
      }
     };
    //a function saved in a variable is a method

     object1.fun();


     function display(param){
        console.log(param);
     }

     display(2);


     //passing a function in another function
     function run(param){
        param();
     }


     //this is a callback function
     run(function() {
      console.log('hello4');
     });

     //seTimeout() allows us to run a function in the future
    
     //built-in function: 1- function to run in the future; 2- after how many milisecond to show
     setTimeout( function(){
      console.log('timeout');
      console.log('timeout2');
     }, 3000);

     //asychronous code -cp won't wait for the timeout line to finish to go to the other one
     //synchronous code - will wait for one line to finish before going to the next one

     /* console.log('next line');

     //set interval - asychronous, but will keep showing the interval every 3 mins
     setInterval(
      function(){
        console.log('interval');
      }, 3000
     ); */

     [
      'make dinner',
      'mash dishes',
      'watch youtube'
     ].forEach( function(value, index){
        console.log(value, index);
        if (value === 'wash dishes'){
            return; // ends reaction early like continur in for loops
        }
     });
      //forEach() mathod prefered way to print out the array
   
     
      [
      'make dinner',
      'mash dishes',
      'watch youtube'
     ].forEach((value, index) => {console.log(value, index);
        if (value === 'wash dishes'){
            return; // ends reaction early like continur in for loops
        }
      }
     );




     const regularFunction = function (param) {
      console.log('hello');
      return 5;
     };

     //works like a normal function 
     const arrowFunction = (param) => {
      console.log('hello');
      return 5;
     }
    arrowFunction();

    //arrow functions has shortcuts compared to regurlar functions - as there is only 1 parameter here - we can rewrite the first line w/o the parathensis around the param

    const oneParam = param=> {
      console.log(param + 1 );
     };
     oneParam(2);

    const oneLine = () => {
      return 2+3; 
    };
     
    //when the arrow function has only one line -> the curly brackets are optional
  const oneLine2=() => 2 + 3; ; 
    console.log(oneLine2());

  
    const object2 ={
      method: () => { //arrow function

      },
      method() { //shortcut for methods

      }

    }


    //filer();
   //this creates a new array
    console.log([1,-3,5].filter(( value, index) => {
      return value >=0;
    }));
 
    console.log([1,1,3].map(value => value*2));


    //closure - if it has access to that value, it will always have access to that value - value gets packaged together (enclosed) with the function - thus why we call it a closure

    </script>
  </body>
</html>